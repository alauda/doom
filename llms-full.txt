---
url: /apis/advanced-apis/codeQualityTaskSummary.md
---

# CodeQualityTaskSummary



---
url: /apis/advanced-apis/event/index.md
---

# Event APIs



---
url: /apis/advanced-apis/event/search.md
---

# Search



---
url: /apis/advanced-apis/index.md
---

# 高级 API



---
url: /apis/advanced-apis/log/aggregation.md
---

# Aggregation



---
url: /apis/advanced-apis/log/index.md
---

# Log APIs



---
url: /apis/advanced-apis/log/search.md
---

# Search



---
url: /apis/advanced-apis/projects.md
---

# Projects



---
url: /apis/crds/ArtifactCleanupRun.md
---

# ArtifactCleanupRun



---
url: /apis/crds/index.md
---

# CRDs



---
url: /apis/index.md
---

# APIs

The `apis` entry is only for demonstration purposes. It is not a real API.



---
url: /apis/references/CodeQuality.md
---

# CodeQuality



---
url: /apis/references/CodeQualityBranch.md
---

# CodeQualityBranch



---
url: /apis/references/index.md
---

# 公共引用



---
url: /index.md
---

# 基本介绍

Doom 是基于 [rspress](https://rspress.dev/zh/) 开发的、适用于 Alauda 内部使用的文档开发工具，它通过实现丰富的内置插件方便文档用户开箱即用。

## 基础能力

* 自动生成可配置权重（顺序）的左侧侧边栏
* 静态文档全文搜索
* 多语言支持

## 基于 Markdown 及其扩展 MDX

MDX 是一种功能强大的内容开发方式。你不仅仅可以像往常一样编写 Markdown 文件，而且可以在 Markdown 的内容中使用 React 组件：

![](https://lf3-static.bytednsdoc.com/obj/eden-cn/uhbfnupenuhf/rspress/mdx-intro.png)

详情可以查看[「使用 MDX」 文档](https://rspress.dev/zh/guide/basic/use-mdx)。

## 开始尝试

下面让我们[快速开始](/zh/start.md)使用 Doom 吧！



---
url: /start.md
---

# 开始 \{#start}

## 创建项目 \{#create}

首先，你可以通过以下命令创建一个新目录：

```bash
mkdir my-docs && cd my-docs
```

执行 `npm init -y` 来初始化一个项目。你可以使用 npm、yarn 或 pnpm 安装 doom:

然后通过如下命令创建文件:

```bash
# 创建 docs 目录，默认支持中英文双语
mkdir docs/en && echo '# Hello World' > docs/en/index.md
mkdir docs/zh && echo '# 你好世界' > docs/zh/index.md
```

在 `package.json` 中加上如下的脚本:

```json
{
  "scripts": {
    "dev": "doom dev",
    "build": "doom build",
    "new": "doom new",
    "serve": "doom serve",
    "translate": "doom translate",
    "export": "doom export"
  }
}
```

然后初始化一个配置文件 `doom.config.yml`:

```yaml
title: My Docs
```

同时新建 `tsconfig.json`，内容如下：

```jsonc
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true,
    "target": "ESNext",
  },
  "mdx": {
    "checkMdx": true,
  },
}
```

最后创建 `global.d.ts` 文件，内容如下：

```ts
/// <reference types="@alauda/doom/runtime" />
```

这样你便可以在 `.mdx` 文件中类型安全地使用 doom 提供的全局组件了。

## 命令行工具 \{#cli}

```bash
doom -h

# output
Usage: doom [options] [command]

Doctor Doom making docs.

Options:
  -V, --version                   output the version number
  -c, --config <config>           Specify the path to the config file
  -v <version>                    Specify the version of the documentation, can also be `unversioned` or `unversioned-x.y`
  -b, --base <base>               Override the base of the documentation
  -p, --prefix <prefix>           Specify the prefix of the documentation base
  -f, --force [boolean]           Force to
                                  1. fetch latest reference remotes or scaffolding templates, otherwise use local cache
                                  2. translate ignore hash equality check and original text (default: false)
  -i, --ignore [boolean]          Ignore internal routes (default: false)
  -d, --download [boolean]        Display download pdf link on nav bar (default: false)
  -e, --export [boolean]          Run or build in exporting PDF mode, `apis/**` and `*/apis/**` routes will be ignored automatically (default: false)
  -I, --include <language...>     Include **only** the specific language(s), `en ru` for example
  -E, --exclude <language...>     Include all languages except the specific language(s), `ru` for example
  -o, --out-dir <path>            Override the `outDir` defined in the config file or the default `dist/{base}/{version}`, the resulting path will be `dist/{outDir}/{version}`
  -r, --redirect <enum>           Whether to redirect to the locale closest to `navigator.language` when the user visits the site, could be `auto`, `never` or `only-default-lang` (default: "only-default-lang")
  -R, --edit-repo [boolean|url]   Whether to enable or override the `editRepoBaseUrl` config feature, `https://github.com/` prefix could be omitted (default: false)
  -a, --algolia                   Whether to enable Algolia search (default: false)
  -S, --site-url                  Whether to enable the siteUrl for sitemap generation (default: false)
  -n, --no-open [boolean]         Do not open the browser after starting the server
  -h, --help                      display help for command

Commands:
  dev [options] [root]            Start the development server
  build [root]                    Build the documentation
  preview|serve [options] [root]  Preview the built documentation
  new [template]                  Generate scaffolding from templates
  translate [options] [root]      Translate the documentation
  export [options] [root]         Export the documentation as PDF, `apis/**` and `*/apis/**` routes will be ignored automatically
  lint [root]                     Lint the documentation
  help [command]                  display help for command
```

更多配置请参考[配置](/zh/usage/configuration.md)

### 启动开发服务 \{#dev}

执行 `yarn dev` 启动开发服务，浏览器会自动打开文档首页

```sh
doom dev -h

# output
Usage: doom dev [options] [root]

Start the development server

Arguments:
  root                      Root directory of the documentation

Options:
  -H, --host [host]         Dev server host name
  -P, --port [port]         Dev server port number
  -l, --lazy [boolean]      Whether to enable `lazyCompilation` which could improve the compilation performance (default: false)
  -h, --help                display help for command
```

### 生产环境构建 \{#build}

执行 `yarn build` 构建生产环境代码，构建完成后会在 `dist` 目录生成静态文件

### 本地预览 \{#serve}

执行 `yarn serve` 预览构建后的静态文件，注意如果使用了 `-b`, `-p` 参数构建，预览时也需要使用 `-b`, `-p` 参数

### 使用脚手架模板 \{#new}

执行 `yarn new` 使用脚手架模板生成项目、模块或文档

### 翻译文档 \{#translate}

```bash
doom translate -h

# output
Usage: doom translate [options] [root]

Translate the documentation

Arguments:
  root                     Root directory of the documentation

Options:
  -s, --source <language>  Document source language, one of en, zh, ru (default: "en")
  -t, --target <language>  Document target language, one of en, zh, ru (default: "zh")
  -g, --glob <path...>     Glob patterns for source dirs/files
  -C, --copy [boolean]     Wether to copy relative assets to the target directory instead of following links (default: false)
  -h, --help               display help for command
```

* `-g, --glob` 参数必填，可以指定需要翻译的文件目录或路径，支持 `glob` 语法，注意参数值必须带引号否则会被命令行解析造成非预期行为。示例：
  1. `yarn translate -g abc xyz`，将把 `<root>/<source>/abc`, `<root>/<source>/xyz`
     目录下的所有文档翻译到 `<root>/<target>/abc`, `<root>/<target>/xyz` 目录下
  2. `yarn translate -g '*'` 将翻译 `<root>/<source>` 下的所有文档文件
* `-C, --copy` 参数可选，是否在目标文件不存在时复制本地路径的资源文件到目标目录，默认为 `false`，即改变资源文件的引用路径为引用源路径。示例：
  * 当启动此参数
    1. `/<source>/abc.jpg` 翻译时将复制 `<root>/public/<source>/abc.jpg` 到 `<root>/public/<target>/abc.jpg`，并修改文档中的引用路径为 `/<target>/abc.jpg`
    2. `<root>/<source>/abc.mdx` 文档中的 `./assets/xyz.jpg` 翻译时将复制 `<root>/<source>/assets/xyz.jpg` 到 `<root>/<target>/assets/xyz.jpg`，图片引用路径保持不变
    3. `<root>/<source>/abc.mdx` 文档中的 `./assets/<source>/xyz.jpg` 翻译时将复制 `<root>/<source>/assets/<source>/xyz.jpg` 到 `<root>/<target>/assets/<target>/xyz.jpg`，并修改文档中的引用路径为 `./assets/<target>/xyz.jpg`
  * 当没有启用此参数：
    1. `/<source>/abc.jpg` 翻译时如果 `<root>/public/<target>/abc.jpg` 已存在，将修改文档中的引用路径为 `/<target>/abc.jpg`，否则保持图片引用路径保持不变
    2. `<root>/<source>/abc.mdx` 文档中的 `./assets/<source>/xyz.jpg` 翻译时，如果 `<root>/<target>/assets/<target>/xyz.jpg` 已存在，将修改文档中的引用路径为 `./assets/<target>/xyz.jpg`，否则将修改为 `../<source>/assets/<target>/xyz.jpg`

:::warning
特殊地，如果使用 `-g '*'` 进行全量翻译，将会对比 `source` 和 `target` 目录文件列表，除 `internalRoutes` 之外的不匹配的 `target` 文件将被自动删除
:::

:::tip
翻译功能须在本地配置 `AZURE_OPENAI_API_KEY` 环境变量，请联系各自团队 Leader 获取
:::

文档中可以使用元数据控制翻译行为

```yaml
i18n:
  title:
    en: DevOps Connectors
  additionalPrompts: '此文中的 Connectors 是专有名词，不要翻译'
  disableAutoTranslation: false
title: DevOps 连接器
```

更多配置请参考[翻译配置](/zh/usage/configuration.md#translate)

### 导出 PDF \{#export}

:::warning
请在执行导出操作前先执行 `yarn build` 构建操作
:::

```sh
doom export -h

# output
Usage: doom export [options] [root]

Export the documentation as PDF, `apis/**` and `*/apis/**` routes will be ignored automatically

Arguments:
  root               Root directory of the documentation

Options:
  -H, --host [host]  Serve host name
  -P, --port [port]  Serve port number (default: "4173")
  -h, --help         display help for command
```

执行 `yarn export` 导出文档为 PDF 文件，注意如果使用了 `-b`, `-p` 参数构建，导出时也需要使用 `-b`, `-p` 参数

导出功能依赖 [`playwright`](https://playwright.dev)，流水线请使用 `build-harbor.alauda.cn/frontend/playwright-runner:doom` 作为依赖安装和文档构建的基础镜像，
本地可以设置如下环境变量加速下载：

```dotenv title=".env.yarn"
PLAYWRIGHT_DOWNLOAD_HOST="https://cdn.npmmirror.com/binaries/playwright"
```

### 文档检查 \{#lint}

```sh
doom lint -h

# output
Usage: doom lint [options] [root]

Lint the documentation

Arguments:
  root        Root directory of the documentation

Options:
  -h, --help  display help for command
```

更多配置请参考[文档检查配置](/zh/usage/configuration.md#lint)



---
url: /usage/api.md
---


# API 文档

根据实际业务，我们一般会将 API 分为高级 API 和 CRD (Custom Resource Definition) 两种，因此在目录结构上一般分为：

```sh
├── apis
│   ├── advanced-apis # 高级 API
│   ├── crds # CRDs
│   └── references # 公共引用
```

## 高级 API

```mdx title="advanced-apis/codeQualityTaskSummary.mdx"
# CodeQualityTaskSummary

<OpenAPIPath path="/plugins/v1alpha1/template/codeQuality/task/{task-id}/summary" />
```

参考 [CodeQualityTaskSummary](../apis/advanced-apis/codeQualityTaskSummary)。

### `props`

- `path`: OpenAPI schema `paths` 下的路径
- `pathPrefix`: 可以用于覆盖全局配置中的 `api.pathPrefix`
- `openapiPath`: 参考[指定 openapi 路径](#指定-openapi-路径)

## CRD

```mdx title="crds/ArtifactCleanupRun.mdx"
# ArtifactCleanupRun

<K8sCrd name="artifactcleanupruns.artifacts.katanomi.dev" />
```

参考 [ArtifactCleanupRun](../apis/crds/ArtifactCleanupRun)。

### `props`

- `name`: CRD `metadata.name`
- `crdPath`: 类似[指定 openapi 路径](#指定-openapi-路径)，用于指定特定的 CRD 文件

## 公共引用

```mdx title="references/CodeQuality.mdx"
# CodeQuality

<OpenAPIRef schema="v1alpha1.CodeQuality" />
```

参考 [CodeQuality](../apis/references/CodeQuality)。

### `props`

- `schema`: OpenAPI schema `definitions`(v2) or `component/schemas`(v3) 下的名称
- `openapiPath`: 参考[指定 openapi 路径](#指定-openapi-路径)

## 指定 openapi 路径

对于 `OpenAPIPath` 和 `OpenAPIRef` 组件，默认会在所有 openapi 定义文件中查找至匹配，如果需要指定特定的 openapi 文件，可以使用 `openapiPath` 属性指定：

```mdx
<OpenAPIPath
  path="/plugins/v1alpha1/template/codeQuality/task/{task-id}/summary"
  openapiPath="shared/openapis/katanomi.json"
/>
```



---
url: /usage/configuration.md
---


# 配置 {#configuration}

## 配置文件 {#config-file}

大部分情况下，我们只需要使用静态 `yaml` 配置文件即可，支持 `doom.config.yaml` 或 `doom.config.yml`，对于复杂场景，比如需要动态配置或自定义 `rspress` 插件时，可以使用 `js/ts` 配置文件，支持 `.js/.ts/.mjs/.mts/.cjs/.cts` 多种文件格式。

对于 `js/ts` 配置文件，我们需要导出配置，可以配合 `@alauda/doom/config` 中导出的 `defineConfig` 函数实现类型辅助：

```ts
import { defineConfig } from '@alauda/doom/config'

export default defineConfig({})
```

## 基础配置 {#basic}

- `lang`：默认文档语言，为方便大部分项目使用，我们默认支持中英文文档，默认语言为 `en`，如果当前文档项目不需要多语言支持，可以将此项配置为 `null` 或 `undefined`
- `title`：文档标题，会显示在浏览器标签页上
- `logo`：文档左上角 logo，支持图片链接、文件路径，绝对路径代表 `public` 目录下的文件，相对路径代表相对于当前工具目录的文件，默认使用 `doom` 包内置的 alauda logo
- `logoText`：文档标题，会显示在左上角的 logo 处
- `icon`：文档 favicon，默认同 `logo`
- `base`：文档基础路径，用于部署到非根路径，如 `product-docs`，默认为 `/`
- `outDir`：构建产物目录，默认为 `dist/{base}/{version}`，如果指定此项，则变更为 `dist/{outDir}/{version}`，其中 `version` 可选，参考[多版本构建](./deploy#多版本构建)

## API 文档配置 {#api}

```yaml
api:
  # CRD 定义文件路径，相对于 doom.config.* 所在目录，支持 glob 匹配，json/yaml 文件
  crds:
    - docs/shared/crds/*.yaml
  # OpenAPI 定义文件路径，相对于 doom.config.* 所在目录，支持 glob 匹配，json/yaml 文件
  openapis:
    - docs/shared/openapis/*.json
  # 渲染 openapi 相关的资源定义时，默认会在页面内联，如果需要将相关联的资源定义单独提取到文件中，可以配置以下选项
  # 参考 https://doom.alauda.cn/apis/references/CodeQuality.html#v1alpha1.CodeQualitySpec
  references:
    v1alpha1.CodeQualityBranch: /apis/references/CodeQualityBranch#v1alpha1.CodeQualityBranch
  # 可选，API 文档路径前缀，如果当前业务使用 gateway 等代理服务，可以配置此项
  pathPrefix: /apis
```

文档编写参考 [API 文档](./api)

## 权限说明文档配置 {#permission}

```yaml
# 以下资源文件路径，相对于 doom.config.* 所在目录，支持 glob 匹配，json/yaml 文件
permission:
  functionresources:
    # `kubectl get functionresources`
    - docs/shared/functionresources/*.yaml
  roletemplates:
    # `kubectl get roletemplates -l auth.cpaas.io/roletemplate.official=true`
    - docs/shared/roletemplates/*.yaml
```

文档编写参考[权限说明文档](./permission)

## 引用文档配置 {#reference}

```yaml
reference:
  - repo: alauda-public/product-doc-guide # 可选，引用文档仓库地址，如果不填写，则默认使用当前文档仓库地址
    branch: # [string] 可选，引用文档仓库分支
    publicBase: # [string] 可选，使用远程仓库时使用绝对路径 /images/xx.png 对应的静态资源所在目录，默认为 docs/public
    sources:
      - name: anchor # 引用文档名称，用于在文档中引用，全局唯一
        path: docs/index.mdx#介绍 # 引用文档路径，支持锚点定位，远程仓库相对于仓库根目录，本地相对于 doom.config.* 所在目录
        ignoreHeading: # [boolean] 可选，是否忽略标题，如果为 true，则不会在引用文档中显示锚点的标题
        processors: # 可选，引用文档内容处理器
          - type: ejsTemplate
            data: # ejs 模板参数，使用 `<%= data.xx %>` 访问
        frontmatterMode: merge # 可选，引用文档处理 frontmatter 模式，默认为 ignore，可选值为 ignore/merge/replace/remove
```

### `frontmatterMode`

- `ignore`：忽略引用文档的 frontmatter，保留使用当前文档的 frontmatter
- `merge`：合并引用文档的 frontmatter，如果有相同的 key，引用文档的值会覆盖当前文档的值
- `replace`：使用引用文档的 frontmatter 替换当前文档的 frontmatter
- `remove`：移除当前文档的 frontmatter

文档编写参考[引用文档](./reference#reference)

## 发行说明配置 {#release-notes}

```yaml
releaseNotes:
  queryTemplates:
    fixed: # 可包含 ejs 模板的 jql 语句
    unfixed:
```

```md title="release-notes.md"
<!-- release-notes-for-bugs?template=fixed&project=DevOps -->
```

```mdx title="release-notes.mdx"
{/* release-notes-for-bugs?template=fixed&project=DevOps */}
```

以上述 `template=fixed&project=DevOps` 为例，`fixed` 为 `queryTemplates` 中定义的模板名称，剩余的 `query` 参数 `project=DevOps` 将作为 [`ejs`](https://github.com/mde/ejs) 模板参数传递给 `fixed` 模板处理后作为 jira [`jql`](https://www.atlassian.com/zh/software/jira/guides/jql/overview#what-is-jql) 发起 `https://jira.alauda.cn/rest/api/2/search?jql=<jql>` 请求，此 API 要求鉴权，须提供 `JIRA_USERNAME` 和 `JIRA_PASSWORD` 环境变量才能预览生效

## 左导航配置 {#sidebar}

```yaml
sidebar:
  collapsed: false # 可选，是否默认折叠左导航，默认折叠，文档内容不多时可以考虑设置为 false
```

## 内部文档路由配置 {#internal-routes}

```yaml
internalRoutes: # 可选，支持 glob 匹配，相对于 docs 目录，在 cli 启用 `-i, --ignore` 选项时匹配到的路由/文件会被忽略
  - '*/internal/**'
```

## 仅包含文档路由配置 {#only-include-routes}

```yaml
onlyIncludeRoutes: # 可选，支持 glob 匹配，相对于 docs 目录，在 cli 启用 `-i, --ignore` 选项时只有此配置下的路由/文件会被启用，可同时配合 `internalRoutes` 进一步排除其中的部分路由
  - '*/internal/**'
internalRoutes:
  - '*/internal/overview.mdx'
```

## 语言高亮插件配置 {#highlight}

```yaml
shiki:
  theme: # optional, https://shiki.style/themes
  langs: # optional, https://shiki.style/languages
  transformers: # optional, only available in js/ts config, https://shiki.style/guide/transformers
```

:::warning
未配置的语言将在命令行提示告警，并回退到 `plaintext` 渲染
:::

## `sites.yaml` 配置 {#sites}

`sites.yaml` 配置文件用于配置当前文档站点关联的子站点信息，[引用外部站点组件](./mdx#externalsite)和构建单版本文档时会用到此处定义的信息。

```yaml
- name: connectors # 全站唯一名称
  base: /devops-connectors # 站点访问基础路径
  version: v1.1 # 构建多版本站点时 ExternalSite/ExternalSiteLink 跳转的版本

  displayName: # 站点显示名称，如果不填写或未匹配到语言，则默认使用 name
    en: DevOps Connectors
    zh: DevOps 连接器

  # 以下属性用于构建全站点时拉取镜像，如果不填写则在最终打包完整网站时将忽略此项
  # 一般对子站点引用需要配置相关信息，对父站点引用不需要配置
  repo: https://github.com/AlaudaDevops/connectors-operator # 站点仓库地址，如果是内部 gitlab 仓库，可以直接使用相关 slug，如 `alauda/product-docs`
  image: devops/connectors-docs # 站点构建镜像，用于构建全站点时拉取镜像
```

## 翻译配置 {#translate}

```yaml
translate:
  # 系统提示语，ejs 模板，传入的参数有 `sourceLang`, `targetLang`, `userPrompt` 和 `additionalPrompts`
  # 其中 `sourceLang` 和 `targetLang` 是 `中文` 和 `英文` 两个字符串，
  #     `userPrompt` 为下述用户全局配置，可能为空
  #     `additionalPrompts` 为文档 `frontmatter.i18n` 中的 `additionalPrompts` 配置，可能为空
  # 默认的系统提示语如下，可以根据实际情况进行修改
  systemPrompt: |
## 角色
你是一位专业的技术文档工程师，擅长写作高质量的<%= targetLang %>技术分档。请你帮我准确地将以下<%= sourceLang %>翻译成<%= targetLang %>，风格与<%= targetLang %>技术文档保持一致。

## 规则
- 第一条消息为需要翻译的最新<%= sourceLang %>文档，第二条消息为之前翻译过的但内容可能过期的<%= targetLang %>文档，如果没有翻译过则为空
- 输入格式为 MDX 格式，输出格式也必须保留原始 MDX 格式，不要翻译其中的 jsx 组件名称，如 <Overview />，且不要额外包装在不必要的代码块中
- 文档中的资源链接不要翻译和替换
- MDX 组件中包含的内容需要翻译，MDX 组件名和参数值不需要翻译，但特殊的 MDX 组件参数值需要翻译，示例：
  - <Overview /> 中的 Overview 是组件名，不用翻译
  - <Tab label="value">组件包含的内容</Tab>，label 是 key 不用翻译，"value" 是参数值需要翻译
<%= terms %>
- 如果存在下列注释，请保留不用翻译，更不要修改注释内容
  - {/* release-notes-for-bugs */}
  - <!-- release-notes-for-bugs -->
- 如果存在下列注释，请整体移除不要保留
  - {/* reference-start */}
  - {/* reference-end */}
  - <!-- reference-start -->
  - <!-- reference-end -->
- 翻译过程中务必保留原文中的 \\< 和 \\{ 转义字符不要做任何转义变更
- 翻译过程中不要破坏原有的 Markdown 格式，如 frontmatter, 代码块、列表、表格等，其中 frontmatter.ii8n 的内容不用做任何翻译，只需要原样返回即可

## 策略
分四步进行翻译工作：
1. 根据<%= sourceLang %>文档直译成<%= targetLang %>，保持原有格式，不要遗漏任何信息
2. 根据第一步直译的结果，指出其中存在的具体问题，要准确描述，不宜笼统的表示，也不要增加原文不存在的内容或格式，包括不仅限于
 - 不符合<%= targetLang %>表达习惯，明确指出不符合的地方
 - 语句不通顺，指出位置，不需要给出修改意见，意译时修复
 - 晦涩难懂，模棱两可，不易理解，可以尝试给出解释
3. 根据第一步直译的结果和第二步指出的问题，重新进行意译，保证内容的原意的基础上，使其更易于理解，更符合<%= targetLang %>技术文档的表达习惯，同时保持原有的格式不变
4. 当存在之前翻译过的<%= targetLang %>文档时，将第三步的结果分段与之前的<%= targetLang %>文档细致地比较，不要遗漏任何新的分段（包括文本、资源链接等），如果分段内翻译结果意思相近，仅仅表达方式不同的，且没有新增任何内容时，则该分段只需要保持之前翻译过的内容即可，不需要重复翻译

最终只需要输出最后一步的结果，不需要输出之前步骤的结果。

<%= userPrompt %>

<%= additionalPrompts %>
  userPrompt: # 可选，用于填充到 `systemPrompt` 中的 `ejs` 模板全局参数
```

## 在代码仓库编辑文档 {#edit-repo}

```yaml
editRepoBaseUrl: alauda/doom/tree/main/docs # https://github.com/ 前缀可以省略，仅当启用 `-R, --edit-repo` 命令行标志符时生效
```

## 文档检查配置 {#lint}

```yaml
lint:
  cspellOptions: # 可选，cspell 配置项，参考 https://github.com/streetsidesoftware/cspell/tree/main/packages/cspell-eslint-plugin#options
```

## Algolia 搜索配置 {#algolia}

```yaml
algolia: # 可选，Algolia 搜索配置，仅当启用 `-a, --algolia` 命令行标志符时生效
  appId: # Algolia 应用 ID
  apiKey: # Algolia API Key
  indexName: # Algolia 索引名称
```

请使用 `public/robots.txt` 进行 Algolia 爬虫验证

## Sitemap 配置 {#sitemap}

```yaml
siteUrl: https://docs.alauda.cn # 可选，站点 URL，用于生成 sitemap，仅当启用 `-S, --site-url` 命令行标志符时生效
```



---
url: /usage/convention.md
---


# 约定

## 目录结构

左侧边栏默认基于文件目录结构自动生成，一级目录中 `index` 文件即文档首页，将展示为左导航首项，子文件夹中可以使用 `index.md` 或 `index.mdx` 并定义文档一级标题来设置左侧边栏分组标题，其他子文档将自动归并到当前分组下，嵌套子文件夹也遵循相同规则。

```sh
├── index.md
├── start.mdx
└── usage
    ├── index.mdx
    └── convention.md
```

同时我们约定

1. `public` 目录用于存放静态资源，如图片、视频等
2. `public/_remotes` 用于存放[远程引用文档](./reference)关联的静态资源，请勿直接依赖该目录的资源，可以将 `*/public/_remotes` 加入 `.gitignore` 避免提交到代码仓库
3. `shared` 目录用于存放公共组件、可复用的文档等，不会自动生成文档数据。

## 元数据

在文档的开头，可以通过 `frontmatter` 来定义文档的元数据，如标题、描述、作者、分类等。

```yaml
---
title: 标题
description: 描述
author: 作者
category: 分类
---
```

在文档正文中，参考 [MDX](./mdx) 使用 `.mdx` 文件时可以使用 `frontmatter` 来访问这些元数据。

## 排序

除 `index.md` 或 `index.mdx` 外，其他文档将默认按照文件名排序，可以通过自定义 `frontmatter` 中的 `weight` 值来调整文档在左侧边栏中的排序（`weight` 值越小排序越靠前）。

```yaml
---
weight: 1
---
```

::: warning
注意：目前左导航配置的变更需要重启服务才能生效，一般开发时不用过多关注。
:::

## 预览

有时在分组首页中我们不需要显示特别的内容，这时可以使用 `index.mdx` 文件并使用 `Overview` 组件来展示当前分组的文档列表，将展示分组列表文件的标题、描述和二级标题信息。

```mdx
# 使用

<Overview />
```

效果可以参考[使用](./)。



---
url: /usage/deploy.md
---


# 部署

## 构建与预览

在部署之前，我们需要先对项目进行生产环境的构建，并在本地进行预览，以确保项目能够正常运行：

```bash
doom build # 构建静态产物
doom serve # 以生产模式预览构建产物
```

## 多版本构建

默认情况下，`doom build` 会将构建产物输出到 `dist` 目录，如果需要构建多个版本的文档，可以通过 `-v` 参数指定版本号，例如：

```bash
# 一般由分支名确定，如 release-4.0 对应 4.0 版本
doom build -v 4.0 # 构建 4.0 版本，产物输出到 dist/4.0，文档访问路径为 {base}/4.0
doom build -v master # 构建 master 版本，产物输出到 dist/master，文档访问路径为 {base}/master
doom build -v {other} # 构建其他版本，产物输出到 dist/{other}，文档访问路径为 {base}/{other}

# unversioned 和 unversioned-x.y 为特殊版本号，用于构建无版本号前缀的文档
doom build -v unversioned # 构建无版本号前缀的文档，产物输出到 dist/unversioned，文档访问路径为 {base}
doom build -v unversioned-4.0 # 构建无版本号前缀但导航栏展示版本号 4.0 的文档，产物输出到 dist/unversioned，文档访问路径为 {base}
```

## 合并目录结构

```sh
│── console-platform
│   ├── 4.0
│   ├── 4.1
│   ├── index.html
│   ├── overrides.yaml
│   └── versions.yaml
│── console-devops-docs
│   ├── 4.0
│   ├── 4.1
│   ├── index.html
│   ├── overrides.yaml
│   └── versions.yaml
│── console-tekton-docs
│   ├── 1.0
│   ├── 1.1
│   ├── index.html
│   ├── overrides.yaml
│   └── versions.yaml
```

```html title="index.html"
<!DOCTYPE html>
<html>
  <head>
    <title>Redirecting...</title>
    <meta http-equiv="refresh" content="0; url=/console-docs/4.1" />
  </head>
  <body>
    <p>Redirecting to <a href="/console-docs/4.1">/console-docs/4.1</a></p>
  </body>
</html>
```

## 动态挂载配置文件 \{#overrides}

```yaml title="overrides.yaml"
# 文档信息，每个文档都可以挂载覆盖默认配置
title:
  en: Doom - Alauda
  zh: Doom - 灵雀云
logoText:
  en: Doom - Alauda
  zh: Doom - 灵雀云
```

```yaml title="versions.yaml"
- '4.1'
- '4.0'
```



---
url: /usage/i18n.md
---


# 国际化

`alauda` 内部大部分文档都是中英文双语，因此我们默认支持使用 `en`/`zh` 两个子文件夹来存放不同语言的文档，推荐在 `public` 目录下也按 `en`/`zh` 子文件夹存放静态资源，这样可以方便文档内容和静态资源的管理。

## `i18n.json`

对于可复用组件，如果需要在同一个组件中同时支持中英文，那么就需要先在 `docs` 目录下创建 `i18n.json` 文件，然后在组件中通过 `useI18n` 来获取当前语言的文本，比如：

```json title=docs/i18n.json
{
  "title": {
    "zh": "标题",
    "en": "Title"
  },
  "description": {
    "zh": "描述",
    "en": "description"
  }
}
```

## `.ts/.tsx`

```tsx
import { useI18n } from '@rspress/runtime'

export const CommonContent = () => {
  const t = useI18n()
  return <h1>{t('title')}</h1>
}
```

## `.mdx`

```mdx
import { useI18n } from '@rspress/runtime'

# {useI18n()('title')}

{useI18n()('description')}
```



---
url: /usage/index.md
---

# 使用



---
url: /usage/markdown.md
---


# Markdown

除了标准的 [gfm](https://github.github.com/gfm) 语法外，Doom 内置了一些额外的 Markdown 扩展功能。

## Callouts

源码标注组件

::: note

1. 请根据实际语言使用行内代码注释，如 `;`, `%`, `#`, `//`, `/** */`, `--` 和 `<!-- -->` 等
2. 如果需要将其视为代码注释，请使用 `[\!code callout]` 进行转义
3. 有时，`:::callouts` 由于嵌套缩进导致解析显示异常，可以使用 `<div class="doom-callouts">` 或 `<Callouts>` 组件代替

:::

````mdx
```sh
Memory overhead per virtual machine ≈ (1.002 × requested memory) \
              + 218 MiB \  # [!code callout]
              + 8 MiB × (number of vCPUs) \  # [!code callout]
              + 16 MiB × (number of graphics devices) \  # [!code callout]
              + (additional memory overhead) # [!code callout]
```

:::callouts

1. Required for the processes that run in the `virt-launcher` pod.
2. Number of virtual CPUs requested by the virtual machine.
3. Number of virtual graphics cards requested by the virtual machine.
4. Additional memory overhead:
   - If your environment includes a Single Root I/O Virtualization (SR-IOV) network device or a Graphics Processing Unit (GPU), allocate 1 GiB additional memory overhead for each device.
   - If Secure Encrypted Virtualization (SEV) is enabled, add 256 MiB.
   - If Trusted Platform Module (TPM) is enabled, add 53 MiB.

:::
````

```sh
Memory overhead per virtual machine ≈ (1.002 × requested memory) \
              + 218 MiB \  # [!code callout]
              + 8 MiB × (number of vCPUs) \  # [!code callout]
              + 16 MiB × (number of graphics devices) \  # [!code callout]
              + (additional memory overhead) # [!code callout]
```

:::callouts

1. Required for the processes that run in the `virt-launcher` pod.
2. Number of virtual CPUs requested by the virtual machine.
3. Number of virtual graphics cards requested by the virtual machine.
4. Additional memory overhead:
   - If your environment includes a Single Root I/O Virtualization (SR-IOV) network device or a Graphics Processing Unit (GPU), allocate 1 GiB additional memory overhead for each device.
   - If Secure Encrypted Virtualization (SEV) is enabled, add 256 MiB.
   - If Trusted Platform Module (TPM) is enabled, add 53 MiB.

:::

更多源码转换功能请参考 [Shiki Transformers](https://shiki.style/packages/transformers#transformers)。

## [Mermaid](https://mermaid.js.org)

图表绘制工具

````mdx
```mermaid
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
```
````

```mermaid
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
```

配合 [Markdown Preview Mermaid](https://github.com/mjbvz/vscode-markdown-mermaid) 可以在 VSCode 中实时预览。



---
url: /usage/mdx.md
---

# MDX

[MDX](https://mdxjs.com/) 是一种 Markdown 的扩展语法，允许在 Markdown 中使用 JSX 语法，使用方式可以参考 [rspress MDX](https://rspress.dev/zh/guide/basic/use-mdx)。

## rspress 组件

`rspress` 主题提供的[内置组件](https://rspress.dev/zh/guide/default-theme/components)大部分已调整为全局组件，可以在 `.mdx` 文件中无需导入直接使用，包括：

* `Badge`
* `Card`
* `LinkCard`
* `PackageManagerTabs`
* `Steps`
* `Tab/Tabs`
* `Toc`

其他不常用的组件可以通过 `@rspress/core/theme` 导入使用，例如：

```mdx title="preview.mdx"
import { SourceCode } from '@rspress/core/theme'

<SourceCode href="/" />
```

## doom 组件

`doom` 提供了一些全局组件来辅助文档编写，不需要导入即可直接使用，目前包括：

### `Overview`

文档概览组件，用于展示文档目录

### `Directive`

有时，由于嵌套缩进，[自定义容器](https://rspress.dev/zh/guide/basic/use-mdx#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8)语法可能失效，可以使用 `Directive` 组件代替

```mdx
- 多语言文档(`doc/en`)的目录结构需要与 `doc/zh` 目录下的文档完全一致，保证多语言文档的链接除了语言标识外完全相同。

  <Directive type="danger" title="注意">
    如果是使用自动化翻译工具进行翻译，则无需关心该问题，自动化翻译工具会自动根据
    `doc/zh` 生成目标语言文档的目录结构。
  </Directive>
```

* 多语言文档(`doc/en`)的目录结构需要与 `doc/zh` 目录下的文档完全一致，保证多语言文档的链接除了语言标识外完全相同。

  如果是使用自动化翻译工具进行翻译，则无需关心该问题，自动化翻译工具会自动根据
  `doc/zh` 生成目标语言文档的目录结构。

### `ExternalSite`

引用外部站点组件

```mdx
<ExternalSite name="connectors" />
```

### `ExternalSiteLink`

引用外部站点链接组件

```mdx
<ExternalSiteLink name="connectors" href="link.mdx#hash" children="Content" />
```

:::tip

在 mdx 中 `<ExternalSiteLink name="connectors" href="link" children="Content" />` 与下面的内容含义不同

```mdx
<ExternalSiteLink name="connectors" href="link">
  Content {/* 将渲染在 `p` 元素内 */}
</ExternalSiteLink>
```

如果不希望文本渲染在 `p` 元素内，可以像上面的示例一样使用 `children` 属性传递

:::

### `AcpApisOverview` 与 `ExternalApisOverview`

引用外部站点 API 概览组件

```mdx
<AcpApisOverview />
{/* same as following */}
<ExternalApisOverview name="acp" />

<ExternalApisOverview name="connectors" />
```

### Term

术语组件，纯文本，动态挂载注入

```mdx
<Term name="company" textCase="capitalize" />
<Term name="product" textCase="lower" />
<Term name="productShort" textCase="upper" />
```

#### `props`

* `name`: 内置术语名称，参考[动态挂载配置文件](/zh/usage/deploy.md#overrides)
* `textCase`: 文本大小写转换，可选值为`lower`, `upper`, `capitalize`

### `TermsTable`

内置术语列表展示组件

```mdx
<TermsTable />
```

#### `props`

* `terms`: `NormalizedTermItem[]`，可选，自定义术语列表，方便内部文档渲染自定义术语时复用

### `JsonViewer`

```mdx
<JsonViewer value={{ key: 'value' }} />
```

## 自定义组件复用

根据[约定](/zh/usage/convention.md)，我们可以将需要复用的内容抽取到 `shared` 目录中，然后在需要的地方引入即可，比如：

```mdx
import CommonContent from './shared/CommonContent.mdx'

<CommonContent />
```

如果需要使用更多 [runtime](https://rspress.dev/zh/api/client-api/api-runtime) 相关的 API，可以使用 `.jsx/.tsx` 实现组件，然后在 `.mdx` 文件中引入使用。

```tsx
// shared/CommonContent.tsx
export const CommonContent = () => {
  const { page } = usePageData()
  return <div>{page.title}</div>
}

// showcase/content.mdx
import { CommonContent } from './shared/CommonContent'
;<CommonContent />
```

:::warning
注意：目前 `.mdx` 导出的组件不支持 `props` 传参，参考[此 issue](https://github.com/web-infra-dev/rspress/issues/1555)，因此需要传递 `props` 的场景请使用 `.jsx/.tsx` 组件进行开发
:::



---
url: /usage/permission.md
---

# 权限说明文档

```mdx
<K8sPermissionTable functions={['devops-testplans', 'devops-testmodules']} />
```

## `props`

* `functions`: `string[]` - 必填，需要展示的 `FunctionResource` 资源名称数组

## 示例



---
url: /usage/reference.md
---


# 引用文档

在 Markdown 文件中：

```md
<!-- reference-start#name -->

<!-- reference-end -->
```

在 MDX 文件中：

```mdx
{/* reference-start#name */}

{/* reference-end */}
```

上述 `name` 为引用文档的名称，参考[引用文档配置](./configuration#reference)，如果引用的文档内容使用了远程仓库图片静态资源，相关静态资源将自动存储在本地 `<root>/public/_remotes/<name>` 目录下。

以下为使用 `<!-- reference-start#ref -->` 的实例：

<!-- reference-start#ref -->

## 引用文档配置 {#reference}

```yaml
reference:
  - repo: alauda-public/product-doc-guide # 可选，引用文档仓库地址，如果不填写，则默认使用当前文档仓库地址
    branch: # [string] 可选，引用文档仓库分支
    publicBase: # [string] 可选，使用远程仓库时使用绝对路径 /images/xx.png 对应的静态资源所在目录，默认为 docs/public
    sources:
      - name: anchor # 引用文档名称，用于在文档中引用，全局唯一
        path: docs/index.mdx#介绍 # 引用文档路径，支持锚点定位，远程仓库相对于仓库根目录，本地相对于 doom.config.* 所在目录
        ignoreHeading: # [boolean] 可选，是否忽略标题，如果为 true，则不会在引用文档中显示锚点的标题
        processors: # 可选，引用文档内容处理器
          - type: ejsTemplate
            data: # ejs 模板参数，使用 `<%= data.xx %>` 访问
        frontmatterMode: merge # 可选，引用文档处理 frontmatter 模式，默认为 ignore，可选值为 ignore/merge/replace/remove
```

### `frontmatterMode`

- `ignore`：忽略引用文档的 frontmatter，保留使用当前文档的 frontmatter
- `merge`：合并引用文档的 frontmatter，如果有相同的 key，引用文档的值会覆盖当前文档的值
- `replace`：使用引用文档的 frontmatter 替换当前文档的 frontmatter
- `remove`：移除当前文档的 frontmatter

文档编写参考[引用文档](./reference#reference)

<!-- reference-end -->


